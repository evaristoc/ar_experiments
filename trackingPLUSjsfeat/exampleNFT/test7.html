<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="author" content="EC">
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui">
        <meta name="mobile-web-app-capable" content="yes">
        <title>Example NFT, based on JSFeat</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans:regular,bold|Inconsolata|PT+Sans:400,700">
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/jsfeat.css">

    </head>
    <body>
            <video id="webcam" width="640" height="480" style="display:none;"></video>
            <div style=" width:640px;height:480px;margin: 10px auto;">
                <canvas id="canvas" width="640" height="480"></canvas>
                <div id="no_rtc" class="alert alert-error" style="display:none;"></div>
                <div id="log" class="alert alert-info"></div>
            </div>

        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/jsfeat-min.js"></script>
        <script type="text/javascript" src="js/compatibility.js"></script>
        <script type="text/javascript" src="js/profiler.js"></script>
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="text/javascript">
            
            
            var app = (function NFT_Module(){
        
                /*--- misc var ---*/
                var _guiGlobal;
                var _optionsGlobal;
                var _ctxGraphics;
                var _canvasWidthGraphics;
                var _canvasHeightGraphics;
                var _statprofiler = new profiler();
                /*--- img related var ---*/
                var _img_u8Global;
                var _img_u8_smoothGlobal;
                var _screen_cornersGlobal;
                var _num_cornersGlobal;
                var _screen_descriptorsGlobal;
                /*--- detection related var ---*/
                var _pattern_cornersGlobal;
                var _pattern_descriptorsGlobal;
                var _pattern_previewGlobal;
                var _num_train_levelsGlobal = 4;
                /*--- matched related var ---*/
                var _matchesGlobal;
                var _homo3x3Global;
                var _match_maskGlobal;
                var _good_matches_numGlobal = [];
                /*--- coordinates of detected object ---*/
                var _startboxGlobal = {x:[],y:[]};
                var _linesboxGlobal = [{x:[],y:[]}, {x:[],y:[]},{x:[],y:[]}, {x:[],y:[]}];
                
                /*--- OPERATIONAL OBJECTS ---*/
                
                // our point match structure
                function Match_t(screen_idx, pattern_lev, pattern_idx, distance) {
                    if (typeof screen_idx === "undefined") { screen_idx=0; }
                    if (typeof pattern_level === "undefined") { pattern_level=0; }
                    if (typeof pattern_idx === "undefined") { pattern_idx=0; }
                    if (typeof distance === "undefined") { distance=0; }
                    this.screen_idx = screen_idx;
                    this.pattern_level = pattern_level;
                    this.pattern_idx = pattern_idx;
                    this.distance = distance;
                };
        
           
                function NFT(){
                    this.options = {
                        blur_size : 5,
                        match_threshold : 30
                    }
                    this.nft;
                };
                
                NFT.prototype.constructor = NFT;
                
                NFT.prototype.test_init = function(){
                    console.log(this);
                };
                
                NFT.prototype.train_pattern_PYRDOWN = function() {
                        var THIS = this; // calls to NFT DIRECTLY not the instantition at app!!!?? Hmmmm....
                        //console.log(this); 
                        /*levels, indexes*/
                        var level=0;
                        var i=0;
                        /*data per level*/
                        var level_corners;
                        var level_descr;
                        var corners_num=0;
                        /*corners: searching parameters*/
                        var sc = 1.0;
                        var max_pattern_size = 512;
                        var max_per_level = 300;
                        var sc_inc = Math.sqrt(2.0); // magic number ;) E: values should be powers of two; we are scaling down
                        var sc0 = Math.min(max_pattern_size/_img_u8Global.cols, max_pattern_size/_img_u8Global.rows);
                        /*matrices: per level analysis*/
                        var level0_img = new jsfeat.matrix_t(_img_u8Global.cols, _img_u8Global.rows, jsfeat.U8_t | jsfeat.C1_t);
                        var level_img = new jsfeat.matrix_t(_img_u8Global.cols, _img_u8Global.rows, jsfeat.U8_t | jsfeat.C1_t);
                        /*resizings and initializations*/
                        var new_width=0;
                        var new_height=0;
                        new_width = (_img_u8Global.cols*sc0)|0;
                        new_height = (_img_u8Global.rows*sc0)|0;
                        jsfeat.imgproc.resample(_img_u8Global, level0_img, new_width, new_height); //of level0_img
                        
                        // prepare preview and run pyrdown
                        _pattern_previewGlobal = new jsfeat.matrix_t(new_width>>1, new_height>>1, jsfeat.U8_t | jsfeat.C1_t);
                        jsfeat.imgproc.pyrdown(level0_img, _pattern_previewGlobal);
                        for(level=0; level < _num_train_levelsGlobal; ++level) {
                            _pattern_cornersGlobal[level] = [];
                            level_corners = _pattern_cornersGlobal[level];
                            // preallocate corners array
                            i = (new_width*new_height) >> level;
                            while(--i >= 0) {
                                level_corners[i] = new jsfeat.keypoint_t(0,0,0,0,-1);
                            }
                            _pattern_descriptorsGlobal[level] = new jsfeat.matrix_t(32, max_per_level, jsfeat.U8_t | jsfeat.C1_t);
                        }
                        // do the first level
                        level_corners = _pattern_cornersGlobal[0];
                        level_descr = _pattern_descriptorsGlobal[0];
                        jsfeat.imgproc.gaussian_blur(level0_img, level_img, this.options.blur_size|0); // this is more robust
                        corners_num = this.detect_keypoints_YAPE06(level_img, level_corners, max_per_level);
                        jsfeat.orb.describe(level_img, level_corners, corners_num, level_descr);
                        console.log("train " + level_img.cols + "x" + level_img.rows + " points: " + corners_num);
                        sc /= sc_inc;
                        // lets do multiple scale levels
                        // we can use Canvas context draw method for faster resize
                        // but its nice to demonstrate that you can do everything with jsfeat
                        for(level = 1; level < _num_train_levelsGlobal; ++level) {
                            level_corners = _pattern_cornersGlobal[level];
                            level_descr = _pattern_descriptorsGlobal[level];
                            new_width = (level0_img.cols*sc)|0;
                            new_height = (level0_img.rows*sc)|0;
                            jsfeat.imgproc.resample(level0_img, level_img, new_width, new_height);
                            jsfeat.imgproc.gaussian_blur(level_img, level_img, this.options.blur_size|0);
                            corners_num = this.detect_keypoints_YAPE06(level_img, level_corners, max_per_level);
                            jsfeat.orb.describe(level_img, level_corners, corners_num, level_descr);
                            // fix the coordinates due to scale level
                            for(i = 0; i < corners_num; ++i) {
                                level_corners[i].x *= 1./sc;
                                level_corners[i].y *= 1./sc;
                            }
                            console.log("train " + level_img.cols + "x" + level_img.rows + " points: " + corners_num);
                            sc /= sc_inc;
                        }
                  };
                  
                 NFT.prototype.detect_keypoints_YAPE06 = function(img, corners, max_allowed){
                        var THIS = this;
                        //console.error('in detect_keypoints_YAPE06', THIS);
                        //detect features
                        var count = jsfeat.yape06.detect(img, corners, 17);
                        // sort by score and reduce the count if needed
                        if(count > max_allowed) {
                            jsfeat.math.qsort(corners, 0, count-1, function(a,b){return (b.score<a.score);});
                            count = max_allowed;
                        }
                        // calculate dominant orientation for each keypoint
                        // E: angles seem to be a requirement for ORB to work? Not explicitly mentioned after calculation
                        for(var i = 0; i < count; ++i) {
                            corners[i].angle = this.HELPERS.ic_angle(img, corners[i].x, corners[i].y);
                        }
                        return count;          
                  };


              NFT.prototype.match_pattern_DESCRIPTORS = function() {
                  var THIS = this;
                  var q_cnt = _screen_descriptorsGlobal.rows;
                  var query_du8 = _screen_descriptorsGlobal.data;
                  var query_u32 = _screen_descriptorsGlobal.buffer.i32; // cast to integer buffer
                  var qd_off = 0;
                  var qidx=0;
                  var level=0;
                  var pidx=0;
                  var k=0;
                  var num_matches = 0;
                  for(qidx = 0; qidx < q_cnt; ++qidx) {
                      var best_dist = 256;
                      var best_dist2 = 256;
                      var best_idx = -1;
                      var best_level = -1;
                      for(level = 0; level < _num_train_levelsGlobal; ++level) {
                          var level_descr = _pattern_descriptorsGlobal[level];
                          var ld_cnt = level_descr.rows;
                          var ld_i32 = level_descr.buffer.i32; // cast to integer buffer
                          var ld_off = 0;
                          for(pidx = 0; pidx < ld_cnt; ++pidx) {
                              var curr_d = 0;
                              // our descriptor is 32 bytes so we have 8 Integers
                              for(k=0; k < 8; ++k) {
                                  curr_d += this.HELPERS.popcnt32( query_u32[qd_off+k]^ld_i32[ld_off+k] );
                              }
                              if(curr_d < best_dist) {
                                  best_dist2 = best_dist;
                                  best_dist = curr_d;
                                  best_level = level;
                                  best_idx = pidx;
                              } else if(curr_d < best_dist2) {
                                  best_dist2 = curr_d;
                              }
                              ld_off += 8; // next descriptor
                          }
                      }
                      // filter out by some threshold
                      if(best_dist < options.match_threshold) {
                          _matchesGlobal[num_matches].screen_idx = qidx;
                          _matchesGlobal[num_matches].pattern_level = best_level;
                          _matchesGlobal[num_matches].pattern_idx = best_idx;
                          num_matches++;
                      }
                      //
                      /* filter using the ratio between 2 closest matches
                      if(best_dist < 0.8*best_dist2) {
                          _matchesGlobal[num_matches].screen_idx = qidx;
                          _matchesGlobal[num_matches].pattern_lev = best_lev;
                          _matchesGlobal[num_matches].pattern_idx = best_idx;
                          num_matches++;
                      }
                      */
                      qd_off += 8; // next query descriptor
                  }
                  return num_matches;
              };

                
                NFT.prototype.find_transform_RANSAC = function(_matchesGlobal, count) {
                   // motion kernel
                   var mm_kernel = new jsfeat.motion_model.homography2d();
                   // ransac params
                   var num_model_points = 4;
                   var reproj_threshold = 3;
                   var ransac_param = new jsfeat.ransac_params_t(num_model_points,
                                                                 reproj_threshold, 0.5, 0.99);
                   var pattern_xy = [];
                   var screen_xy = [];
                   // construct correspondences
                   for(var i = 0; i < count; ++i) {
                       var m = _matchesGlobal[i];
                       var s_kp = _screen_cornersGlobal[m.screen_idx];
                       var p_kp = _pattern_cornersGlobal[m.pattern_level][m.pattern_idx];
                       pattern_xy[i] = {"x":p_kp.x, "y":p_kp.y};
                       screen_xy[i] =  {"x":s_kp.x, "y":s_kp.y};
                   }
                   // estimate motion
                   var ok = false;
                   ok = jsfeat.motion_estimator.ransac(ransac_param, mm_kernel,
                                                       pattern_xy, screen_xy, count, _homo3x3Global, _match_maskGlobal, 1000);
                   // extract good matches and re-estimate
                   var good_cnt = 0;
                   if(ok) {
                       for(var i=0; i < count; ++i) {
                           if(_match_maskGlobal.data[i]) {
                               pattern_xy[good_cnt].x = pattern_xy[i].x;
                               pattern_xy[good_cnt].y = pattern_xy[i].y;
                               screen_xy[good_cnt].x = screen_xy[i].x;
                               screen_xy[good_cnt].y = screen_xy[i].y;
                               good_cnt++;
                           }
                       }
                       // run kernel directly with inliers only
                       mm_kernel.run(pattern_xy, screen_xy, _homo3x3Global, good_cnt);
                   } else {
                       jsfeat.matmath.identity_3x3(_homo3x3Global, 1.0);
                   }
                   return good_cnt;
               };
               


                NFT.prototype.HELPERS = (function(){
                              return {
                                    u_max : new Int32Array([15,15,15,15,14,14,14,13,13,12,11,10,9,8,6,3,0]),
                                    ic_angle : function(img, px, py){
                                          var half_k = 15; // half patch size
                                          /*unitarian points?*/
                                          var m_01 = 0;
                                          var m_10 = 0;
                                          /*img data*/
                                          var src=img.data;
                                          var step=img.cols;
                                          /*2d projection*/
                                          var u=0;
                                          var v=0;
                                          var center_off=(py*step + px)|0;
                                          /*distances & modules parameters*/
                                          var v_sum=0;
                                          var d=0;
                                          var val_plus=0;
                                          var val_minus=0;
                                          // Treat the center line differently, v=0
                                          for (u = -half_k; u <= half_k; ++u) //E: changing the value of u :/
                                              m_10 += u * src[center_off+u];
                                          // Go line by line in the circular patch
                                          for (v = 1; v <= half_k; ++v) {
                                              // Proceed over the two lines
                                              v_sum = 0;
                                              d = this.u_max[v];
                                              for (u = -d; u <= d; ++u) {
                                                  val_plus = src[center_off+u+v*step];
                                                  val_minus = src[center_off+u-v*step];
                                                  v_sum += (val_plus - val_minus);
                                                  m_10 += u * (val_plus + val_minus);
                                              }
                                              m_01 += v * v_sum;
                                          }
                                          return Math.atan2(m_01, m_10);                              
                                      },
                                    popcnt32 : function(n){
                                          n -= ((n >> 1) & 0x55555555);
                                          n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
                                          return (((n + (n >> 4))& 0xF0F0F0F)* 0x1010101) >> 24;                              
                                    },
                                    tcorners : function(M, w, h) {
                                          var pt = [ {'x':0,'y':0}, {'x':w,'y':0}, {'x':w,'y':h}, {'x':0,'y':h} ];
                                          var z=0.0, i=0, px=0.0, py=0.0;
                                          for (; i < 4; ++i) {
                                              px = M[0]*pt[i].x + M[1]*pt[i].y + M[2];
                                              py = M[3]*pt[i].x + M[4]*pt[i].y + M[5];
                                              z = M[6]*pt[i].x + M[7]*pt[i].y + M[8];
                                              pt[i].x = px/z;
                                              pt[i].y = py/z;
                                          }
                                          return pt;
                                    },
                                    average : function(arr){
                                            if (arr.length === 0) {
                                              return
                                            }else {
                                              let s = arr.reduce((a,b)=>{return a+b}, false);
                                              return s/arr.length;
                                            }                
                                    },
                                   linesegmentsintersect: function(x1, y1, x2, y2, x3, y3, x4, y4){
                                            //var a_dx = Math.abs(x2 - x1);
                                            //var a_dy = Math.abs(y2 - y1);
                                            //var b_dx = Math.abs(x4 - x3);
                                            //var b_dy = Math.abs(y4 - y3);
                                            var a_dx = x2 - x1;
                                            var a_dy = y2 - y1;
                                            var b_dx = x4 - x3;
                                            var b_dy = y4 - y3;          
                                            var s = (-a_dy * (x1 - x3) + a_dx * (y1 - y3)) / (-b_dx * a_dy + a_dx * b_dy);
                                            var t = (+b_dx * (y1 - y3) - b_dy * (x1 - x3)) / (-b_dx * a_dy + a_dx * b_dy);
                                            return (s >= 0 && s <= 1 && t >= 0 && t <= 1);                        
                                      }                               
                                };
                  
                  
                  }());

              
             
              NFT.prototype.boundbox_coords = function(){
                  // get the projected pattern corners
                  var THIS = this;
                  console.log(this);
                  const avesize = 20;
                  const maxdevX = 25; //pixels
                  const maxdevY = 25; //pixels
                  var findminmaxX = [];
                  var findminmaxY = [];
                 
                  
                  function _updatecoord(current_coord, previous_coords, dev, l=false, coord=false){
                      let proposed_coord;
                      let average = THIS.HELPERS.average(previous_coords);
                      switch(current_coord){
                          case current_coord < average - dev:
                              proposed_coord = average - dev;
                              break;
                          case current_coord > average + dev:
                              proposed_coord =  average + dev;
                              break;
                          default:
                              proposed_coord = current_coord;
                      };
                      previous_coords.shift();
                      previous_coords.push(proposed_coord);
                      if (l && coord) {
                        if (coord === 'x') {
                            findminmaxX.push(THIS.HELPERS.average(previous_coords));
                        }else if (coord === 'y') {
                            findminmaxY.push(THIS.HELPERS.average(previous_coords));
                        }
                      }
                      return previous_coords
                  };

                  try{
                    var shape_pts = THIS.Graphics.tCorners(_homo3x3Global.data, _pattern_previewGlobal.cols*2, _pattern_previewGlobal.rows*2);
                  }catch(error){
                    console.log('At outerbox_coords, tCorners did not run', error);
                  }
                
                  var intersect = false;
                  if (THIS.HELPERS.linesegmentsintersect(shape_pts[0].x,shape_pts[0].y, shape_pts[1].x,shape_pts[1].y, shape_pts[2].x,shape_pts[2].y, shape_pts[3].x,shape_pts[3].y)) {
                    intersect = true;
                  };
                  if (THIS.HELPERS.linesegmentsintersect(shape_pts[1].x,shape_pts[1].y, shape_pts[2].x,shape_pts[2].y, shape_pts[3].x,shape_pts[3].y, shape_pts[0].x,shape_pts[0].y)) {
                    intersect = true;
                  };
                  if (!intersect) {
                    for (let i = 0; i < 4; ++i){
                        if (i === 0) {
                          if (_startboxGlobal.x.length < avesize) {
                            _startboxGlobal.x.push(shape_pts[i].x)
                          }else{
                            _startboxGlobal.x = _updatecoord(shape_pts[i].x, _startboxGlobal.x, maxdevX);
                          };
                          if (_startboxGlobal.y.length < avesize) {
                            _startboxGlobal.y.push(shape_pts[i].y)
                          }else{
                            _startboxGlobal.y = _updatecoord(shape_pts[i].y, _startboxGlobal.y, maxdevY);
                          }
                        };
                        if (_linesboxGlobal[i].x.length < avesize) {
                          _linesboxGlobal[i].x.push(shape_pts[i].x)
                        }else{
                          _linesboxGlobal[i].x = _updatecoord(shape_pts[i].x, _linesboxGlobal[i].x, maxdevX, true, 'x');
                        };
                        if (_linesboxGlobal[i].y.length < avesize) {
                          _linesboxGlobal[i].y.push(shape_pts[i].y);
                        }else{
                          _linesboxGlobal[i].y = _updatecoord(shape_pts[i].y, _linesboxGlobal[i].y, maxdevY, true, 'y');
                        }
                    };
                  };
                  var coords = [];
                  coords.push(Math.min(...findminmaxX));
                  coords.push(Math.min(...findminmaxY));
                  coords.push(Math.max(...findminmaxX));
                  coords.push(Math.max(...findminmaxY));
                  COORDS = [];
                  return COORDS.push(coords);
                };
              

              NFT.prototype.Graphics = {
                    render_pattern_shape : function(_ctxGraphics) {
                                var THIS = this;
                                _ctxGraphics.strokeStyle = "rgb(0,0,255)";
                                _ctxGraphics.beginPath();                                     
                                _ctxGraphics.moveTo(THIS.HELPERS.average(_startboxGlobal.x),THIS.HELPERS.average(_startboxGlobal.y));
                                for(let i = 1; i < 4; ++i){
                                  _ctxGraphics.lineTo(THIS.HELPERS.average(_linesboxGlobal[i].x),THIS.HELPERS.average(_linesboxGlobal[i].y));
                                }
                                _ctxGraphics.lineTo(THIS.HELPERS.average(_linesboxGlobal[0].x),THIS.HELPERS.average(_linesboxGlobal[0].y));
              
                                _ctxGraphics.lineWidth=4;
                                _ctxGraphics.stroke();
                            },
                    render_corners : function(corners, count, img, step) {
                                var pix = (0xff << 24) | (0x00 << 16) | (0xff << 8) | 0x00; //color??? pixeling??? Clever...
                                for(var i=0; i < count; ++i)
                                {
                                    var x = corners[i].x;
                                    var y = corners[i].y;
                                    var off = (x + y * step);
                                    img[off] = pix;
                                    img[off-1] = pix;
                                    img[off+1] = pix;
                                    img[off-step] = pix;
                                    img[off+step] = pix;
                                }
                            },
                    render_mono_image : function(src, dst, sw, sh, dw) {
                                var alpha = (0xff << 24);
                                for(var i = 0; i < sh; ++i) {
                                    for(var j = 0; j < sw; ++j) {
                                        var pix = src[i*sw+j];
                                        dst[i*dw+j] = alpha | (pix << 16) | (pix << 8) | pix;
                                    }
                                }
                            }
                
                
                };
                
                /*--- PRIVATE FUNCTIONS setup ---*/
                
                
                /*--- Middleware ---*/
                
                
                /*--- PUBLIC FUNCTIONS ---*/
                function app(videoWidth, videoHeight) {
                   //var THIS = this;
                   //`this` points to window global, so it will find variables there for canvas, but the ctx is specific to NFT
                   (function canvas_setup(){
                      _canvasWidthGraphics  = canvas.width;
                      _canvasHeightGraphics = canvas.height;
                      _ctxGraphics = canvas.getContext('2d');
                      _ctxGraphics.fillStyle = "rgb(0,255,0)";
                      _ctxGraphics.strokeStyle = "rgb(0,255,0)";            
                    }());
                   
                   (function patternimg_init(){
                      _img_u8Global = new jsfeat.matrix_t(640, 480, jsfeat.U8_t | jsfeat.C1_t);
                      // after blur
                      _img_u8_smoothGlobal = new jsfeat.matrix_t(640, 480, jsfeat.U8_t | jsfeat.C1_t);            
                      // we wll limit to 500 strongest points
                      _screen_descriptorsGlobal = new jsfeat.matrix_t(32, 500, jsfeat.U8_t | jsfeat.C1_t);
                      _pattern_descriptorsGlobal = [];
                      _screen_cornersGlobal = [];
                      _pattern_cornersGlobal = [];
                      _matchesGlobal = [];
                      var i = 640*480;
                      while(--i >= 0) {
                          _screen_cornersGlobal[i] = new jsfeat.keypoint_t(0,0,0,0,-1);
                          _matchesGlobal[i] = new Match_t();
                      }
                      // transform matrix
                      _homo3x3Global = new jsfeat.matrix_t(3,3,jsfeat.F32C1_t);
                      _match_maskGlobal = new jsfeat.matrix_t(500,1,jsfeat.U8C1_t);
                    }());
        
                   this.nftInstance = new NFT();
                   //options.test_init();
                   _guiGlobal = new dat.GUI();
                   _guiGlobal.add(this.nftInstance.options, "blur_size", 3, 9).step(1);
                   _guiGlobal.add(this.nftInstance.options, "match_threshold", 16, 128);
                   _guiGlobal.add(this.nftInstance, "train_pattern_PYRDOWN");
                   _statprofiler.add("grayscale");
                   _statprofiler.add("gauss blur");
                   _statprofiler.add("keypoints");
                   _statprofiler.add("orb descriptors");
                   _statprofiler.add("matching");
               };
               
              function tick(t) {// tick WON'T BE BOUND to nft! It will be bound to an object that CONTAINS it, PASSED FROM app!
                  compatibility.requestAnimationFrame(tick.bind(this)); //although the same object, each binding IS DIFFERENT, so it is STATELESS!!
                  //console.error(this.nft);
                  _statprofiler.new_frame();
                  if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                      _ctxGraphics.drawImage(this.video, 0, 0, 640, 480);
              //        //_ctxGraphics.drawImage(foto, 100,100);
                      var imageData = _ctxGraphics.getImageData(0, 0, 640, 480);
                      _statprofiler.start("grayscale");
                      jsfeat.imgproc.grayscale(imageData.data, 640, 480, _img_u8Global);
                      _statprofiler.stop("grayscale");
                      _statprofiler.start("gauss blur");
                      jsfeat.imgproc.gaussian_blur(_img_u8Global, _img_u8_smoothGlobal, this.nftInstance.options.blur_size|0);
                      _statprofiler.stop("gauss blur");
                      jsfeat.fast_corners.set_threshold(this.nftInstance.options.match_threshold);
                      _statprofiler.start("keypoints");
                      _num_cornersGlobal = this.nftInstance.detect_keypoints_YAPE06(_img_u8_smoothGlobal, _screen_cornersGlobal, 500);
                      _statprofiler.stop("keypoints");
                      _statprofiler.start("orb descriptors");
                      jsfeat.orb.describe(_img_u8_smoothGlobal, _screen_cornersGlobal, _num_cornersGlobal, _screen_descriptorsGlobal);
                      _statprofiler.stop("orb descriptors");
                      // render result back to canvas
                      var data_u32 = new Uint32Array(imageData.data.buffer);
                      this.nft.Graphics.render_corners(_screen_cornersGlobal, _num_cornersGlobal, data_u32, 640);
                      // render pattern and matches
                      var num_matches = 0;
                      var good_matches = 0;
                      if(_pattern_previewGlobal) {
                          this.nftInstance.Graphics.render_mono_image(_pattern_previewGlobal.data, data_u32, _pattern_previewGlobal.cols, _pattern_previewGlobal.rows, 640);
                          _statprofiler.start("matching");
                          num_matches = this.nftInstance.match_pattern();
              //            good_matches = this.nft.find_transform_RANSAC(_matchesGlobal, num_matches);
              //            _statprofiler.stop("matching");
              //        };
              //        
                    //  _ctxGraphics.putImageData(imageData, 0, 0);
              //        
              //        if(num_matches) {
              //            render_matches(_ctxGraphics, _matchesGlobal, num_matches);
              //            //if(good_matches > 8)
              //            //    render_pattern_shape(_ctxGraphics);
              //            if (_good_matches_numGlobal.length > 20) {
              //              _good_matches_numGlobal.shift();
              //            };
              //            if(good_matches > 5){
              //              _good_matches_numGlobal.push(1);
              //            }else{
              //              _good_matches_numGlobal.push(0);
              //              COORDS = [[NaN, NaN, NaN, NaN]];
              //            };
              //            if (_good_matches_numGlobal && _good_matches_numGlobal.reduce((a,b)=>{return a+b},0)/_good_matches_numGlobal.length > .5) {
              //                console.log(_good_matches_numGlobal);
              //                render_pattern_shape(_ctxGraphics);
              //                //render_hull(_ctxGraphics, _matchesGlobal, num_matches);
              //                
              //              }
              //            }
              //
                      $('#log').html(_statprofiler.log());
                  }
              };
              
              return {app: app, tick: tick, video: null};
        
            }());
            
            
            (function setup(app_EXTERNAL, tick_EXTERNAL){

                const WIDTH = 480;
                const HEIGHT = 360;
                var canvas;
                var _ctxSETUP;
                var video;
                const width = Math.round(60 * WIDTH / HEIGHT);
                const height = 60;
      
                /*--- PRIVATE FUNCTIONS setup ---*/
                function _detectmob(){
                    if( navigator.userAgent.match(/Android/i)
                    || navigator.userAgent.match(/webOS/i)
                    || navigator.userAgent.match(/iPhone/i)
                    || navigator.userAgent.match(/iPad/i)
                    || navigator.userAgent.match(/iPod/i)
                    || navigator.userAgent.match(/BlackBerry/i)
                    || navigator.userAgent.match(/Windows Phone/i)
                    ){
                       return true;
                     }
                    else {
                       return false;
                     }        
                }
                /*--- Middleware ---*/
                function _findVideoSizeMiddleW(){
                    var THIS = this;
                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        _onDimensionsReadyMiddleW(video.videoWidth, video.videoHeight);
                        video.removeEventListener('loadeddata', function(e){_findVideoSizeMiddleW()});
                    } else {
                          if(attempts < 10) {
                              attempts++;
                              setTimeout(_findVideoSizeMiddleW, 200);
                          } else {
                             _onDimensionsReadyMiddleW(640, 480);
                          }
                      };
                  };
                  
                  function _onDimensionsReadyMiddleW(width, height){
                      var THIS = this;
                      app_EXTERNAL.app(width, height);
                      var counter = 0;
                      //function _updateframes(t){
                      //      app_EXTERNAL.video = video;
                      //      console.log(t);
                      //      app_EXTERNAL.tick();                       
                      //};
                      //compatibility.requestAnimationFrame(_updateframes); //leave function!!
                      //app_EXTERNAL.video = video;
                      app_EXTERNAL.tick(); 
                  };
                
                var init_obj = {
                    canvas_init : function(){
                              var THIS = this;
                              canvas = document.getElementById('canvas');
                              canvas.width = WIDTH;
                              canvas.height = HEIGHT;
                              _ctxSETUP = canvas.getContext('2d');
                              _ctxSETUP.fillStyle = "rgb(0,255,0)";
                              _ctxSETUP.strokeStyle = "rgb(0,255,0)";
                            },
                    video_init : function(){
                              var THIS = this;
                              video = document.getElementById('webcam');
                              app_EXTERNAL.video = video;
                              try{
                                  //console.log(video);
                                  video.addEventListener('loadeddata', function(e){_findVideoSizeMiddleW()});
                                  var attemps = 0;
                                  var voptions = {};
                                  var mob = _detectmob();
                                  if (mob) {
                                    voptions = { video: { facingMode: { exact: "environment" }, width: WIDTH, height: HEIGHT }, audio:false }
                                  }else{
                                    voptions = {video: {width: WIDTH, height: HEIGHT}, audio: false}
                                  };
                                  compatibility.getUserMedia(voptions,
                                                              function(stream){
                                                                const videoS = document.querySelector('video');
                                                                try {
                                                                    //deprecated
                                                                    videoS.src = compatibility.URL.createObjectURL(stream);
                                                                  }catch(error){
                                                                    videoS.srcObject = stream;
                                                                  };
                                                                  setTimeout(function(){videoS.play();},500);
                                                              },
                                                              function(error){
                                                                  $('#canvas').hide();
                                                                  $('#log').hide();
                                                                  $('#no_rtc').html('<h4>WebRTC not available.</h4>');
                                                                  $('#no_rtc').show();
                                                              });
                                  
                                }catch(error){
                                  $('#canvas').hide();
                                  $('#log').hide();
                                  $('#no_rtc').html('<h4>Something goes wrong...</h4>');
                                  $('#no_rtc').show();                        
                                }
                            },
                  };
                  
                $(window).load(function(){
                    'use strict';
                    init_obj.canvas_init();
                    init_obj.video_init();               
                })
              }(app,2))
            
        </script>
    </body>
</html>
