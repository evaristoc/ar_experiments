<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="author" content="EC">
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui">
        <meta name="mobile-web-app-capable" content="yes">
        <title>Example NFT, based on JSFeat</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans:regular,bold|Inconsolata|PT+Sans:400,700">
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/jsfeat.css">

    </head>
    <body>
            <video id="webcam" width="640" height="480" style="display:none;"></video>
            <div style=" width:640px;height:480px;margin: 10px auto;">
                <canvas id="canvas" width="640" height="480"></canvas>
                <div id="no_rtc" class="alert alert-error" style="display:none;"></div>
                <div id="log" class="alert alert-info"></div>
            </div>

        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/jsfeat-min.js"></script>
        <script type="text/javascript" src="js/compatibility.js"></script>
        <script type="text/javascript" src="js/profiler.js"></script>
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="text/javascript">
            
            
            var app = (function NFT_Module(){
        
                /*--- misc var ---*/
                var gui;
                var options;
                var ctx;
                var canvasWidth;
                var canvasHeight;
                var stat = new profiler();
                /*--- img related var ---*/
                var img_u8;
                var img_u8_smooth;
                var screen_corners;
                var num_corners;
                var screen_descriptors;
                /*--- detection related var ---*/
                var pattern_corners;
                var pattern_descriptors;
                var pattern_preview;
                var num_train_levels = 4;
                /*--- matched related var ---*/
                var matches;
                var homo3x3;
                var match_mask;
                var good_matches_num = [];
                /*--- coordinates of detected object ---*/
                var startbox = {x:[],y:[]};
                var linesbox = [{x:[],y:[]}, {x:[],y:[]},{x:[],y:[]}, {x:[],y:[]}];
                
                /*--- OPERATIONAL OBJECTS ---*/
                
                // our point match structure
                function Match_t(screen_idx, pattern_lev, pattern_idx, distance) {
                    if (typeof screen_idx === "undefined") { screen_idx=0; }
                    if (typeof pattern_level === "undefined") { pattern_level=0; }
                    if (typeof pattern_idx === "undefined") { pattern_idx=0; }
                    if (typeof distance === "undefined") { distance=0; }
                    this.screen_idx = screen_idx;
                    this.pattern_level = pattern_level;
                    this.pattern_idx = pattern_idx;
                    this.distance = distance;
                };
        
           
                function NFT(){
                    this.blur_size = 5;
                    this.match_threshold = 30;
                };
                
                NFT.prototype.constructor = NFT;
                
                NFT.prototype.test_init = function(){
                    console.log(this);
                };
                
                NFT.prototype.train_pattern_PYRDOWN = function() {
                        var THIS = this;
                        console.log(this);
                        /*levels, indexes*/
                        var level=0;
                        var i=0;
                        /*data per level*/
                        var level_corners;
                        var level_descr;
                        var corners_num=0;
                        /*corners: searching parameters*/
                        var sc = 1.0;
                        var max_pattern_size = 512;
                        var max_per_level = 300;
                        var sc_inc = Math.sqrt(2.0); // magic number ;) E: values should be powers of two; we are scaling down
                        var sc0 = Math.min(max_pattern_size/img_u8.cols, max_pattern_size/img_u8.rows);
                        /*matrices: per level analysis*/
                        var level0_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
                        var level_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
                        /*resizings and initializations*/
                        var new_width=0;
                        var new_height=0;
                        new_width = (img_u8.cols*sc0)|0;
                        new_height = (img_u8.rows*sc0)|0;
                        jsfeat.imgproc.resample(img_u8, level0_img, new_width, new_height); //of level0_img
                        
                        // prepare preview and run pyrdown
                        pattern_preview = new jsfeat.matrix_t(new_width>>1, new_height>>1, jsfeat.U8_t | jsfeat.C1_t);
                        jsfeat.imgproc.pyrdown(level0_img, pattern_preview);
                        for(level=0; level < num_train_levels; ++level) {
                            pattern_corners[level] = [];
                            level_corners = pattern_corners[level];
                            // preallocate corners array
                            i = (new_width*new_height) >> level;
                            while(--i >= 0) {
                                level_corners[i] = new jsfeat.keypoint_t(0,0,0,0,-1);
                            }
                            pattern_descriptors[level] = new jsfeat.matrix_t(32, max_per_level, jsfeat.U8_t | jsfeat.C1_t);
                        }
                        // do the first level
                        level_corners = pattern_corners[0];
                        level_descr = pattern_descriptors[0];
                        jsfeat.imgproc.gaussian_blur(level0_img, level_img, options.blur_size|0); // this is more robust
                        corners_num = THIS.detect_keypoints_YAPE06(level_img, level_corners, max_per_level);
                        jsfeat.orb.describe(level_img, level_corners, corners_num, level_descr);
                        console.log("train " + level_img.cols + "x" + level_img.rows + " points: " + corners_num);
                        sc /= sc_inc;
                        // lets do multiple scale levels
                        // we can use Canvas context draw method for faster resize
                        // but its nice to demonstrate that you can do everything with jsfeat
                        for(level = 1; level < num_train_levels; ++level) {
                            level_corners = pattern_corners[level];
                            level_descr = pattern_descriptors[level];
                            new_width = (level0_img.cols*sc)|0;
                            new_height = (level0_img.rows*sc)|0;
                            jsfeat.imgproc.resample(level0_img, level_img, new_width, new_height);
                            jsfeat.imgproc.gaussian_blur(level_img, level_img, options.blur_size|0);
                            corners_num = THIS.detect_keypoints_YAPE06(level_img, level_corners, max_per_level);
                            jsfeat.orb.describe(level_img, level_corners, corners_num, level_descr);
                            // fix the coordinates due to scale level
                            for(i = 0; i < corners_num; ++i) {
                                level_corners[i].x *= 1./sc;
                                level_corners[i].y *= 1./sc;
                            }
                            console.log("train " + level_img.cols + "x" + level_img.rows + " points: " + corners_num);
                            sc /= sc_inc;
                        }
                  };
                  
                 NFT.prototype.detect_keypoints_YAPE06 = function(img, corners, max_allowed){
                        var THIS = this;
                        console.log(THIS);
                        //detect features
                        var count = jsfeat.yape06.detect(img, corners, 17);
                        // sort by score and reduce the count if needed
                        if(count > max_allowed) {
                            jsfeat.math.qsort(corners, 0, count-1, function(a,b){return (b.score<a.score);});
                            count = max_allowed;
                        }
                        // calculate dominant orientation for each keypoint
                        // E: angles seem to be a requirement for ORB to work? Not explicitly mentioned after calculation
                        for(var i = 0; i < count; ++i) {
                            corners[i].angle = this.HELPERS.ic_angle(img, corners[i].x, corners[i].y);
                        }
                        return count;          
                  };

                NFT.prototype.HELPERS = (function(){
                              return {
                                    u_max : new Int32Array([15,15,15,15,14,14,14,13,13,12,11,10,9,8,6,3,0]),
                                    ic_angle : function(img, px, py){
                                          var half_k = 15; // half patch size
                                          /*unitarian points?*/
                                          var m_01 = 0;
                                          var m_10 = 0;
                                          /*img data*/
                                          var src=img.data;
                                          var step=img.cols;
                                          /*2d projection*/
                                          var u=0;
                                          var v=0;
                                          var center_off=(py*step + px)|0;
                                          /*distances & modules parameters*/
                                          var v_sum=0;
                                          var d=0;
                                          var val_plus=0;
                                          var val_minus=0;
                                          // Treat the center line differently, v=0
                                          for (u = -half_k; u <= half_k; ++u) //E: changing the value of u :/
                                              m_10 += u * src[center_off+u];
                                          // Go line by line in the circular patch
                                          for (v = 1; v <= half_k; ++v) {
                                              // Proceed over the two lines
                                              v_sum = 0;
                                              d = this.u_max[v];
                                              for (u = -d; u <= d; ++u) {
                                                  val_plus = src[center_off+u+v*step];
                                                  val_minus = src[center_off+u-v*step];
                                                  v_sum += (val_plus - val_minus);
                                                  m_10 += u * (val_plus + val_minus);
                                              }
                                              m_01 += v * v_sum;
                                          }
                                          return Math.atan2(m_01, m_10);                              
                                      },
                                    popcnt32 : function(n){
                                          n -= ((n >> 1) & 0x55555555);
                                          n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
                                          return (((n + (n >> 4))& 0xF0F0F0F)* 0x1010101) >> 24;                              
                                    },
                                    tcorners : function(M, w, h) {
                                          var pt = [ {'x':0,'y':0}, {'x':w,'y':0}, {'x':w,'y':h}, {'x':0,'y':h} ];
                                          var z=0.0, i=0, px=0.0, py=0.0;
                                          for (; i < 4; ++i) {
                                              px = M[0]*pt[i].x + M[1]*pt[i].y + M[2];
                                              py = M[3]*pt[i].x + M[4]*pt[i].y + M[5];
                                              z = M[6]*pt[i].x + M[7]*pt[i].y + M[8];
                                              pt[i].x = px/z;
                                              pt[i].y = py/z;
                                          }
                                          return pt;
                                    },
                                    average : function(arr){
                                            if (arr.length === 0) {
                                              return
                                            }else {
                                              let s = arr.reduce((a,b)=>{return a+b}, false);
                                              return s/arr.length;
                                            }                
                                    },
                                   linesegmentsintersect: function(x1, y1, x2, y2, x3, y3, x4, y4){
                                            //var a_dx = Math.abs(x2 - x1);
                                            //var a_dy = Math.abs(y2 - y1);
                                            //var b_dx = Math.abs(x4 - x3);
                                            //var b_dy = Math.abs(y4 - y3);
                                            var a_dx = x2 - x1;
                                            var a_dy = y2 - y1;
                                            var b_dx = x4 - x3;
                                            var b_dy = y4 - y3;          
                                            var s = (-a_dy * (x1 - x3) + a_dx * (y1 - y3)) / (-b_dx * a_dy + a_dx * b_dy);
                                            var t = (+b_dx * (y1 - y3) - b_dy * (x1 - x3)) / (-b_dx * a_dy + a_dx * b_dy);
                                            return (s >= 0 && s <= 1 && t >= 0 && t <= 1);                        
                                      }                               
                                };
                  
                  
                  }());
              //  
              //  NFT.prototype.find_transform_RANSAC = function(matches, count) {
              //     // motion kernel
              //     var mm_kernel = new jsfeat.motion_model.homography2d();
              //     // ransac params
              //     var num_model_points = 4;
              //     var reproj_threshold = 3;
              //     var ransac_param = new jsfeat.ransac_params_t(num_model_points,
              //                                                   reproj_threshold, 0.5, 0.99);
              //     var pattern_xy = [];
              //     var screen_xy = [];
              //     // construct correspondences
              //     for(var i = 0; i < count; ++i) {
              //         var m = matches[i];
              //         var s_kp = screen_corners[m.screen_idx];
              //         var p_kp = pattern_corners[m.pattern_level][m.pattern_idx];
              //         pattern_xy[i] = {"x":p_kp.x, "y":p_kp.y};
              //         screen_xy[i] =  {"x":s_kp.x, "y":s_kp.y};
              //     }
              //     // estimate motion
              //     var ok = false;
              //     ok = jsfeat.motion_estimator.ransac(ransac_param, mm_kernel,
              //                                         pattern_xy, screen_xy, count, homo3x3, match_mask, 1000);
              //     // extract good matches and re-estimate
              //     var good_cnt = 0;
              //     if(ok) {
              //         for(var i=0; i < count; ++i) {
              //             if(match_mask.data[i]) {
              //                 pattern_xy[good_cnt].x = pattern_xy[i].x;
              //                 pattern_xy[good_cnt].y = pattern_xy[i].y;
              //                 screen_xy[good_cnt].x = screen_xy[i].x;
              //                 screen_xy[good_cnt].y = screen_xy[i].y;
              //                 good_cnt++;
              //             }
              //         }
              //         // run kernel directly with inliers only
              //         mm_kernel.run(pattern_xy, screen_xy, homo3x3, good_cnt);
              //     } else {
              //         jsfeat.matmath.identity_3x3(homo3x3, 1.0);
              //     }
              //     return good_cnt;
              // };
              // 
              //NFT.prototype.match_pattern_DESCRIPTORS = function() {
              //    var THIS = this;
              //    var q_cnt = screen_descriptors.rows;
              //    var query_du8 = screen_descriptors.data;
              //    var query_u32 = screen_descriptors.buffer.i32; // cast to integer buffer
              //    var qd_off = 0;
              //    var qidx=0;
              //    var level=0;
              //    var pidx=0;
              //    var k=0;
              //    var num_matches = 0;
              //    for(qidx = 0; qidx < q_cnt; ++qidx) {
              //        var best_dist = 256;
              //        var best_dist2 = 256;
              //        var best_idx = -1;
              //        var best_level = -1;
              //        for(level = 0; level < num_train_levels; ++level) {
              //            var level_descr = pattern_descriptors[level];
              //            var ld_cnt = level_descr.rows;
              //            var ld_i32 = level_descr.buffer.i32; // cast to integer buffer
              //            var ld_off = 0;
              //            for(pidx = 0; pidx < ld_cnt; ++pidx) {
              //                var curr_d = 0;
              //                // our descriptor is 32 bytes so we have 8 Integers
              //                for(k=0; k < 8; ++k) {
              //                    curr_d += this.HELPERS.popcnt32( query_u32[qd_off+k]^ld_i32[ld_off+k] );
              //                }
              //                if(curr_d < best_dist) {
              //                    best_dist2 = best_dist;
              //                    best_dist = curr_d;
              //                    best_level = level;
              //                    best_idx = pidx;
              //                } else if(curr_d < best_dist2) {
              //                    best_dist2 = curr_d;
              //                }
              //                ld_off += 8; // next descriptor
              //            }
              //        }
              //        // filter out by some threshold
              //        if(best_dist < options.match_threshold) {
              //            matches[num_matches].screen_idx = qidx;
              //            matches[num_matches].pattern_level = best_level;
              //            matches[num_matches].pattern_idx = best_idx;
              //            num_matches++;
              //        }
              //        //
              //        /* filter using the ratio between 2 closest matches
              //        if(best_dist < 0.8*best_dist2) {
              //            matches[num_matches].screen_idx = qidx;
              //            matches[num_matches].pattern_lev = best_lev;
              //            matches[num_matches].pattern_idx = best_idx;
              //            num_matches++;
              //        }
              //        */
              //        qd_off += 8; // next query descriptor
              //    }
              //    return num_matches;
              //};
              //
              //NFT.prototype.tCorners_HELPER = function(M, w, h) {
              //    var pt = [ {'x':0,'y':0}, {'x':w,'y':0}, {'x':w,'y':h}, {'x':0,'y':h} ];
              //    var z=0.0, i=0, px=0.0, py=0.0;
              //    for (; i < 4; ++i) {
              //        px = M[0]*pt[i].x + M[1]*pt[i].y + M[2];
              //        py = M[3]*pt[i].x + M[4]*pt[i].y + M[5];
              //        z = M[6]*pt[i].x + M[7]*pt[i].y + M[8];
              //        pt[i].x = px/z;
              //        pt[i].y = py/z;
              //    }
              //    return pt;
              //};
              //  
              //
              //function average(a){
              //  if (a.length === 0) {
              //    return
              //  }else {
              //    let s = a.reduce((a,b)=>{return a+b}, false);
              //    return s/a.length;
              //  }
              //};
              //  
              //var startbox = {x:[],y:[]};
              //var linesbox = [{x:[],y:[]}, {x:[],y:[]},{x:[],y:[]}, {x:[],y:[]}]
              ////E: one of the functions from:
              ////    https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function
              ////    http://bl.ocks.org/nitaku/fdbb70c3baa36e8feb4e
              //var lineSegmentsIntersect = (x1, y1, x2, y2, x3, y3, x4, y4)=> {
              //    //var a_dx = Math.abs(x2 - x1);
              //    //var a_dy = Math.abs(y2 - y1);
              //    //var b_dx = Math.abs(x4 - x3);
              //    //var b_dy = Math.abs(y4 - y3);
              //    var a_dx = x2 - x1;
              //    var a_dy = y2 - y1;
              //    var b_dx = x4 - x3;
              //    var b_dy = y4 - y3;          
              //    var s = (-a_dy * (x1 - x3) + a_dx * (y1 - y3)) / (-b_dx * a_dy + a_dx * b_dy);
              //    var t = (+b_dx * (y1 - y3) - b_dy * (x1 - x3)) / (-b_dx * a_dy + a_dx * b_dy);
              //    return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
              //};
              //
              //NFT.prototype.Graphics.render_matches = function(ctx, matches, count) {
              //      for(var i = 0; i < count; ++i) {
              //          var m = matches[i];
              //          var s_kp = screen_corners[m.screen_idx];
              //          var p_kp = pattern_corners[m.pattern_lev][m.pattern_idx];
              //          if(match_mask.data[i]) {
              //              ctx.strokeStyle = "rgb(0,255,0)";
              //          } else {
              //              ctx.strokeStyle = "rgb(255,0,0)";
              //          }
              //          ctx.beginPath();
              //          ctx.moveTo(s_kp.x,s_kp.y);
              //          ctx.lineTo(p_kp.x*0.5, p_kp.y*0.5); // our preview is downscaled
              //          ctx.lineWidth=1;
              //          ctx.stroke();
              //      }
              //  };
              //  
              NFT.prototype.Graphics.outerbox_coords = function(){
                  // get the projected pattern corners
                  var THIS = this;
                  console.log(this);
                  const avesize = 20;
                  const maxdevX = 25; //pixels
                  const maxdevY = 25; //pixels
                  var findminmaxX = [];
                  var findminmaxY = [];
                 
                  
                  function _updatecoord(current_coord, previous_coords, dev, l=false, coord=false){
                      let proposed_coord;
                      let average = THIS.HELPERS.average(previous_coords);
                      switch(current_coord){
                          case current_coord < average - dev:
                              proposed_coord = average - dev;
                              break;
                          case current_coord > average + dev:
                              proposed_coord =  average + dev;
                              break;
                          default:
                              proposed_coord = current_coord;
                      };
                      previous_coords.shift();
                      previous_coords.push(proposed_coord);
                      if (l && coord) {
                        if (coord === 'x') {
                            findminmaxX.push(THIS.HELPERS.average(previous_coords));
                        }else if (coord === 'y') {
                            findminmaxY.push(THIS.HELPERS.average(previous_coords));
                        }
                      }
                      return previous_coords
                  };

                  try{
                    var shape_pts = THIS.Graphics.tCorners(homo3x3.data, pattern_preview.cols*2, pattern_preview.rows*2);
                  }catch(error){
                    console.log(error);
                  }
                
                  var intersect = false;
                  if (THIS.HELPERS.linesegmentsintersect(shape_pts[0].x,shape_pts[0].y, shape_pts[1].x,shape_pts[1].y, shape_pts[2].x,shape_pts[2].y, shape_pts[3].x,shape_pts[3].y)) {
                    intersect = true;
                  };
                  if (THIS.HELPERS.linesegmentsintersect(shape_pts[1].x,shape_pts[1].y, shape_pts[2].x,shape_pts[2].y, shape_pts[3].x,shape_pts[3].y, shape_pts[0].x,shape_pts[0].y)) {
                    intersect = true;
                  };
                  if (!intersect) {
                    for (let i = 0; i < 4; ++i){
                        if (i === 0) {
                          if (startbox.x.length < avesize) {
                            startbox.x.push(shape_pts[i].x)
                          }else{
                            startbox.x = _updatecoord(shape_pts[i].x, startbox.x, maxdevX);
                          };
                          if (startbox.y.length < avesize) {
                            startbox.y.push(shape_pts[i].y)
                          }else{
                            lstartbox.y = _updatecoord(shape_pts[i].y, startbox.y, maxdevY);
                          }
                        };
                        if (linesbox[i].x.length < avesize) {
                          linesbox[i].x.push(shape_pts[i].x)
                        }else{
                          linesbox[i].x = _updatecoord(shape_pts[i].x, linesbox[i].x, maxdevX, true, 'x');
                        };
                        if (linesbox[i].y.length < avesize) {
                          linesbox[i].y.push(shape_pts[i].y);
                        }else{
                          linesbox[i].y = _updatecoord(shape_pts[i].y, linesbox[i].y, maxdevY, true, 'y');
                        }
                    };
                  };
                  var coords = [];
                  coords.push(Math.min(...findminmaxX));
                  coords.push(Math.min(...findminmaxY));
                  coords.push(Math.max(...findminmaxX));
                  coords.push(Math.max(...findminmaxY));
                  COORDS = [];
                  return COORDS.push(coords);
                };
              
              NFT.prototype.Graphics.render_pattern_shape = function(ctx, render=true) {
                  var THIS = this;
                  ctx.strokeStyle = "rgb(0,0,255)";
                  ctx.beginPath();                                     
                  ctx.moveTo(THIS.HELPERS.average(startbox.x),THIS.HELPERS.average(startbox.y));
                  for(let i = 1; i < 4; ++i){
                    ctx.lineTo(THIS.HELPERS.average(linesbox[i].x),THIS.HELPERS.average(linesbox[i].y));
                  }
                  ctx.lineTo(THIS.HELPERS.average(linesbox[0].x),THIS.HELPERS.average(linesbox[0].y));

                  ctx.lineWidth=4;
                  ctx.stroke();
              };
              //
              //
              //NFT.prototype.Graphics.render_corners = function(corners, count, img, step) {
              //    var pix = (0xff << 24) | (0x00 << 16) | (0xff << 8) | 0x00;
              //    for(var i=0; i < count; ++i)
              //    {
              //        var x = corners[i].x;
              //        var y = corners[i].y;
              //        var off = (x + y * step);
              //        img[off] = pix;
              //        img[off-1] = pix;
              //        img[off+1] = pix;
              //        img[off-step] = pix;
              //        img[off+step] = pix;
              //    }
              //};
              //
              //
              //NFT.prototype.Graphics.render_mono_image = function(src, dst, sw, sh, dw) {
              //    var alpha = (0xff << 24);
              //    for(var i = 0; i < sh; ++i) {
              //        for(var j = 0; j < sw; ++j) {
              //            var pix = src[i*sw+j];
              //            dst[i*dw+j] = alpha | (pix << 16) | (pix << 8) | pix;
              //        }
              //    }
              //};
                
                /*--- PRIVATE FUNCTIONS setup ---*/
                
                
                /*--- Middleware ---*/
                
                
                /*--- PUBLIC FUNCTIONS ---*/
                function app(videoWidth, videoHeight) {
                   var THIS = this;
                   //console.log(THIS.name === ''?THIS:THIS.name);
                   (function canvas_setup(){
                      canvasWidth  = canvas.width;
                      canvasHeight = canvas.height;
                      ctx = canvas.getContext('2d');
                      ctx.fillStyle = "rgb(0,255,0)";
                      ctx.strokeStyle = "rgb(0,255,0)";            
                    }());
                   
                   (function patternimg_init(){
                      img_u8 = new jsfeat.matrix_t(640, 480, jsfeat.U8_t | jsfeat.C1_t);
                      // after blur
                      img_u8_smooth = new jsfeat.matrix_t(640, 480, jsfeat.U8_t | jsfeat.C1_t);            
                      // we wll limit to 500 strongest points
                      screen_descriptors = new jsfeat.matrix_t(32, 500, jsfeat.U8_t | jsfeat.C1_t);
                      pattern_descriptors = [];
                      screen_corners = [];
                      pattern_corners = [];
                      matches = [];
                      var i = 640*480;
                      while(--i >= 0) {
                          screen_corners[i] = new jsfeat.keypoint_t(0,0,0,0,-1);
                          matches[i] = new Match_t();
                      }
                      // transform matrix
                      homo3x3 = new jsfeat.matrix_t(3,3,jsfeat.F32C1_t);
                      match_mask = new jsfeat.matrix_t(500,1,jsfeat.U8C1_t);
                    }());
        
                   options = new NFT();
                   //options.test_init();
                   gui = new dat.GUI();
                   gui.add(options, "blur_size", 3, 9).step(1);
                   gui.add(options, "match_threshold", 16, 128);
                   gui.add(options, "train_pattern_PYRDOWN");
                   stat.add("grayscale");
                   stat.add("gauss blur");
                   stat.add("keypoints");
                   stat.add("orb descriptors");
                   stat.add("matching");
               };
               
              //function tick() {
              //    compatibility.requestAnimationFrame(tick);
              //    stat.new_frame();
              //    if (video.readyState === video.HAVE_ENOUGH_DATA) {
              //        ctx.drawImage(video, 0, 0, 640, 480);
              //        //ctx.drawImage(foto, 100,100);
              //        var imageData = ctx.getImageData(0, 0, 640, 480);
              //        stat.start("grayscale");
              //        jsfeat.imgproc.grayscale(imageData.data, 640, 480, img_u8);
              //        stat.stop("grayscale");
              //        stat.start("gauss blur");
              //        jsfeat.imgproc.gaussian_blur(img_u8, img_u8_smooth, options.blur_size|0);
              //        stat.stop("gauss blur");
              //        jsfeat.fast_corners.set_threshold(options.match_threshold);
              //        stat.start("keypoints");
              //        num_corners = detect_keypoints(img_u8_smooth, screen_corners, 500);
              //        stat.stop("keypoints");
              //        stat.start("orb descriptors");
              //        jsfeat.orb.describe(img_u8_smooth, screen_corners, num_corners, screen_descriptors);
              //        stat.stop("orb descriptors");
              //        // render result back to canvas
              //        var data_u32 = new Uint32Array(imageData.data.buffer);
              //        render_corners(screen_corners, num_corners, data_u32, 640);
              //        // render pattern and matches
              //        var num_matches = 0;
              //        var good_matches = 0;
              //        if(pattern_preview) {
              //            render_mono_image(pattern_preview.data, data_u32, pattern_preview.cols, pattern_preview.rows, 640);
              //            stat.start("matching");
              //            num_matches = match_pattern();
              //            good_matches = NFT.find_transform_RANSAC(matches, num_matches);
              //            stat.stop("matching");
              //        };
              //        
              //        ctx.putImageData(imageData, 0, 0);
              //        
              //        if(num_matches) {
              //            render_matches(ctx, matches, num_matches);
              //            //if(good_matches > 8)
              //            //    render_pattern_shape(ctx);
              //            if (good_matches_num.length > 20) {
              //              good_matches_num.shift();
              //            };
              //            if(good_matches > 5){
              //              good_matches_num.push(1);
              //            }else{
              //              good_matches_num.push(0);
              //              COORDS = [[NaN, NaN, NaN, NaN]];
              //            };
              //            if (good_matches_num && good_matches_num.reduce((a,b)=>{return a+b},0)/good_matches_num.length > .5) {
              //                console.log(good_matches_num);
              //                render_pattern_shape(ctx);
              //                //render_hull(ctx, matches, num_matches);
              //                
              //              }
              //            }
              //
              //        $('#log').html(stat.log());
              //    }
              //};
              
              return {app: app};
        
            }());
            
            
            (function setup(app_EXTERNAL, tick_EXTERNAL){

                const WIDTH = 480;
                const HEIGHT = 360;
                var canvas;
                var ctx;
                var video;
                const width = Math.round(60 * WIDTH / HEIGHT);
                const height = 60;
      
                /*--- PRIVATE FUNCTIONS setup ---*/
                function _detectmob(){
                    if( navigator.userAgent.match(/Android/i)
                    || navigator.userAgent.match(/webOS/i)
                    || navigator.userAgent.match(/iPhone/i)
                    || navigator.userAgent.match(/iPad/i)
                    || navigator.userAgent.match(/iPod/i)
                    || navigator.userAgent.match(/BlackBerry/i)
                    || navigator.userAgent.match(/Windows Phone/i)
                    ){
                       return true;
                     }
                    else {
                       return false;
                     }        
                }
                /*--- Middleware ---*/
                function _findVideoSizeMiddleW(){
                    var THIS = this;
                    console.log(THIS.name === ''?THIS:THIS.name, width, height);
                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        video.removeEventListener('loadeddata', function(e){_findVideoSizeMiddleW()});
                        _onDimensionsReadyMiddleW(video.videoWidth, video.videoHeight);
                    } else {
                          if(attempts < 10) {
                              attempts++;
                              setTimeout(_findVideoSizeMiddleW, 200);
                          } else {
                             _onDimensionsReadyMiddleW(640, 480);
                          }
                      };
                  };
                  
                  function _onDimensionsReadyMiddleW(width, height){
                      var THIS = this;
                      console.log(THIS.name === ''?THIS:THIS.name, width, height);
                      app_EXTERNAL.app(width, height);
                      //compatibility.requestAnimationFrame(tick_EXTERNAL);
                  };
                
                var init_obj = {
                    canvas_init : function(){
                              var THIS = this;
                              canvas = document.getElementById('canvas');
                              canvas.width = WIDTH;
                              canvas.height = HEIGHT;
                              ctx = canvas.getContext('2d');
                              ctx.fillStyle = "rgb(0,255,0)";
                              ctx.strokeStyle = "rgb(0,255,0)";
                            },
                    video_init : function(){
                              var THIS = this;
                              video = document.getElementById('webcam');
                              try{
                                  console.log(video);
                                  video.addEventListener('loadeddata', function(e){_findVideoSizeMiddleW()});
                                  var attemps = 0;
                                  var voptions = {};
                                  var mob = _detectmob();
                                  if (mob) {
                                    voptions = { video: { facingMode: { exact: "environment" }, width: WIDTH, height: HEIGHT }, audio:false }
                                  }else{
                                    voptions = {video: {width: WIDTH, height: HEIGHT}, audio: false}
                                  };
                                  compatibility.getUserMedia(voptions,
                                                              function(stream){
                                                                const videoS = document.querySelector('video');
                                                                try {
                                                                    //deprecated
                                                                    videoS.src = compatibility.URL.createObjectURL(stream);
                                                                  }catch(error){
                                                                    videoS.srcObject = stream;
                                                                  };
                                                                  setTimeout(function(){videoS.play();},500);
                                                              },
                                                              function(error){
                                                                  $('#canvas').hide();
                                                                  $('#log').hide();
                                                                  $('#no_rtc').html('<h4>WebRTC not available.</h4>');
                                                                  $('#no_rtc').show();
                                                              });
                                  
                                }catch(error){
                                  $('#canvas').hide();
                                  $('#log').hide();
                                  $('#no_rtc').html('<h4>Something goes wrong...</h4>');
                                  $('#no_rtc').show();                        
                                }
                            },
                  };
                  
                $(window).load(function(){
                    'use strict';
                    init_obj.canvas_init();
                    init_obj.video_init();               
                })
              }(app,2))
            
        </script>
    </body>
</html>
